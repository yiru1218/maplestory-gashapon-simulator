{"ast":null,"code":"'use strict';\n\nvar utils = require('./../utils');\nvar settle = require('./../core/settle');\nvar buildFullPath = require('../core/buildFullPath');\nvar buildURL = require('./../helpers/buildURL');\nvar http = require('http');\nvar https = require('https');\nvar httpFollow = require('follow-redirects').http;\nvar httpsFollow = require('follow-redirects').https;\nvar url = require('url');\nvar zlib = require('zlib');\nvar VERSION = require('./../env/data').version;\nvar transitionalDefaults = require('../defaults/transitional');\nvar AxiosError = require('../core/AxiosError');\nvar CanceledError = require('../cancel/CanceledError');\nvar isHttps = /https:?/;\nvar supportedProtocols = ['http:', 'https:', 'file:'];\n\n/**\n *\n * @param {http.ClientRequestArgs} options\n * @param {AxiosProxyConfig} proxy\n * @param {string} location\n */\nfunction setProxy(options, proxy, location) {\n  options.hostname = proxy.host;\n  options.host = proxy.host;\n  options.port = proxy.port;\n  options.path = location;\n\n  // Basic proxy authorization\n  if (proxy.auth) {\n    var base64 = Buffer.from(proxy.auth.username + ':' + proxy.auth.password, 'utf8').toString('base64');\n    options.headers['Proxy-Authorization'] = 'Basic ' + base64;\n  }\n\n  // If a proxy is used, any redirects must also pass through the proxy\n  options.beforeRedirect = function beforeRedirect(redirection) {\n    redirection.headers.host = redirection.host;\n    setProxy(redirection, proxy, redirection.href);\n  };\n}\n\n/*eslint consistent-return:0*/\nmodule.exports = function httpAdapter(config) {\n  return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {\n    var onCanceled;\n    function done() {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(onCanceled);\n      }\n      if (config.signal) {\n        config.signal.removeEventListener('abort', onCanceled);\n      }\n    }\n    var resolve = function resolve(value) {\n      done();\n      resolvePromise(value);\n    };\n    var rejected = false;\n    var reject = function reject(value) {\n      done();\n      rejected = true;\n      rejectPromise(value);\n    };\n    var data = config.data;\n    var headers = config.headers;\n    var headerNames = {};\n    Object.keys(headers).forEach(function storeLowerName(name) {\n      headerNames[name.toLowerCase()] = name;\n    });\n\n    // Set User-Agent (required by some servers)\n    // See https://github.com/axios/axios/issues/69\n    if ('user-agent' in headerNames) {\n      // User-Agent is specified; handle case where no UA header is desired\n      if (!headers[headerNames['user-agent']]) {\n        delete headers[headerNames['user-agent']];\n      }\n      // Otherwise, use specified value\n    } else {\n      // Only set header if it hasn't been set in config\n      headers['User-Agent'] = 'axios/' + VERSION;\n    }\n\n    // support for https://www.npmjs.com/package/form-data api\n    if (utils.isFormData(data) && utils.isFunction(data.getHeaders)) {\n      Object.assign(headers, data.getHeaders());\n    } else if (data && !utils.isStream(data)) {\n      if (Buffer.isBuffer(data)) {\n        // Nothing to do...\n      } else if (utils.isArrayBuffer(data)) {\n        data = Buffer.from(new Uint8Array(data));\n      } else if (utils.isString(data)) {\n        data = Buffer.from(data, 'utf-8');\n      } else {\n        return reject(new AxiosError('Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream', AxiosError.ERR_BAD_REQUEST, config));\n      }\n      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {\n        return reject(new AxiosError('Request body larger than maxBodyLength limit', AxiosError.ERR_BAD_REQUEST, config));\n      }\n\n      // Add Content-Length header if data exists\n      if (!headerNames['content-length']) {\n        headers['Content-Length'] = data.length;\n      }\n    }\n\n    // HTTP basic authentication\n    var auth = undefined;\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      auth = username + ':' + password;\n    }\n\n    // Parse url\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    var parsed = url.parse(fullPath);\n    var protocol = parsed.protocol || supportedProtocols[0];\n    if (supportedProtocols.indexOf(protocol) === -1) {\n      return reject(new AxiosError('Unsupported protocol ' + protocol, AxiosError.ERR_BAD_REQUEST, config));\n    }\n    if (!auth && parsed.auth) {\n      var urlAuth = parsed.auth.split(':');\n      var urlUsername = urlAuth[0] || '';\n      var urlPassword = urlAuth[1] || '';\n      auth = urlUsername + ':' + urlPassword;\n    }\n    if (auth && headerNames.authorization) {\n      delete headers[headerNames.authorization];\n    }\n    var isHttpsRequest = isHttps.test(protocol);\n    var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;\n    try {\n      buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\\?/, '');\n    } catch (err) {\n      var customErr = new Error(err.message);\n      customErr.config = config;\n      customErr.url = config.url;\n      customErr.exists = true;\n      reject(customErr);\n    }\n    var options = {\n      path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\\?/, ''),\n      method: config.method.toUpperCase(),\n      headers: headers,\n      agent: agent,\n      agents: {\n        http: config.httpAgent,\n        https: config.httpsAgent\n      },\n      auth: auth\n    };\n    if (config.socketPath) {\n      options.socketPath = config.socketPath;\n    } else {\n      options.hostname = parsed.hostname;\n      options.port = parsed.port;\n    }\n    var proxy = config.proxy;\n    if (!proxy && proxy !== false) {\n      var proxyEnv = protocol.slice(0, -1) + '_proxy';\n      var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];\n      if (proxyUrl) {\n        var parsedProxyUrl = url.parse(proxyUrl);\n        var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;\n        var shouldProxy = true;\n        if (noProxyEnv) {\n          var noProxy = noProxyEnv.split(',').map(function trim(s) {\n            return s.trim();\n          });\n          shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {\n            if (!proxyElement) {\n              return false;\n            }\n            if (proxyElement === '*') {\n              return true;\n            }\n            if (proxyElement[0] === '.' && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {\n              return true;\n            }\n            return parsed.hostname === proxyElement;\n          });\n        }\n        if (shouldProxy) {\n          proxy = {\n            host: parsedProxyUrl.hostname,\n            port: parsedProxyUrl.port,\n            protocol: parsedProxyUrl.protocol\n          };\n          if (parsedProxyUrl.auth) {\n            var proxyUrlAuth = parsedProxyUrl.auth.split(':');\n            proxy.auth = {\n              username: proxyUrlAuth[0],\n              password: proxyUrlAuth[1]\n            };\n          }\n        }\n      }\n    }\n    if (proxy) {\n      options.headers.host = parsed.hostname + (parsed.port ? ':' + parsed.port : '');\n      setProxy(options, proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);\n    }\n    var transport;\n    var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);\n    if (config.transport) {\n      transport = config.transport;\n    } else if (config.maxRedirects === 0) {\n      transport = isHttpsProxy ? https : http;\n    } else {\n      if (config.maxRedirects) {\n        options.maxRedirects = config.maxRedirects;\n      }\n      if (config.beforeRedirect) {\n        options.beforeRedirect = config.beforeRedirect;\n      }\n      transport = isHttpsProxy ? httpsFollow : httpFollow;\n    }\n    if (config.maxBodyLength > -1) {\n      options.maxBodyLength = config.maxBodyLength;\n    }\n    if (config.insecureHTTPParser) {\n      options.insecureHTTPParser = config.insecureHTTPParser;\n    }\n\n    // Create the request\n    var req = transport.request(options, function handleResponse(res) {\n      if (req.aborted) return;\n\n      // uncompress the response body transparently if required\n      var stream = res;\n\n      // return the last request in case of redirects\n      var lastRequest = res.req || req;\n\n      // if no content, is HEAD request or decompress disabled we should not decompress\n      if (res.statusCode !== 204 && lastRequest.method !== 'HEAD' && config.decompress !== false) {\n        switch (res.headers['content-encoding']) {\n          /*eslint default-case:0*/\n          case 'gzip':\n          case 'compress':\n          case 'deflate':\n            // add the unzipper to the body stream processing pipeline\n            stream = stream.pipe(zlib.createUnzip());\n\n            // remove the content-encoding in order to not confuse downstream operations\n            delete res.headers['content-encoding'];\n            break;\n        }\n      }\n      var response = {\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: res.headers,\n        config: config,\n        request: lastRequest\n      };\n      if (config.responseType === 'stream') {\n        response.data = stream;\n        settle(resolve, reject, response);\n      } else {\n        var responseBuffer = [];\n        var totalResponseBytes = 0;\n        stream.on('data', function handleStreamData(chunk) {\n          responseBuffer.push(chunk);\n          totalResponseBytes += chunk.length;\n\n          // make sure the content length is not over the maxContentLength if specified\n          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {\n            // stream.destoy() emit aborted event before calling reject() on Node.js v16\n            rejected = true;\n            stream.destroy();\n            reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded', AxiosError.ERR_BAD_RESPONSE, config, lastRequest));\n          }\n        });\n        stream.on('aborted', function handlerStreamAborted() {\n          if (rejected) {\n            return;\n          }\n          stream.destroy();\n          reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded', AxiosError.ERR_BAD_RESPONSE, config, lastRequest));\n        });\n        stream.on('error', function handleStreamError(err) {\n          if (req.aborted) return;\n          reject(AxiosError.from(err, null, config, lastRequest));\n        });\n        stream.on('end', function handleStreamEnd() {\n          try {\n            var responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);\n            if (config.responseType !== 'arraybuffer') {\n              responseData = responseData.toString(config.responseEncoding);\n              if (!config.responseEncoding || config.responseEncoding === 'utf8') {\n                responseData = utils.stripBOM(responseData);\n              }\n            }\n            response.data = responseData;\n          } catch (err) {\n            reject(AxiosError.from(err, null, config, response.request, response));\n          }\n          settle(resolve, reject, response);\n        });\n      }\n    });\n\n    // Handle errors\n    req.on('error', function handleRequestError(err) {\n      // @todo remove\n      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;\n      reject(AxiosError.from(err, null, config, req));\n    });\n\n    // set tcp keep alive to prevent drop connection by peer\n    req.on('socket', function handleRequestSocket(socket) {\n      // default interval of sending ack packet is 1 minute\n      socket.setKeepAlive(true, 1000 * 60);\n    });\n\n    // Handle request timeout\n    if (config.timeout) {\n      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.\n      var timeout = parseInt(config.timeout, 10);\n      if (isNaN(timeout)) {\n        reject(new AxiosError('error trying to parse `config.timeout` to int', AxiosError.ERR_BAD_OPTION_VALUE, config, req));\n        return;\n      }\n\n      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.\n      // And timer callback will be fired, and abort() will be invoked before connection, then get \"socket hang up\" and code ECONNRESET.\n      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.\n      // And then these socket which be hang up will devoring CPU little by little.\n      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.\n      req.setTimeout(timeout, function handleRequestTimeout() {\n        req.abort();\n        var transitional = config.transitional || transitionalDefaults;\n        reject(new AxiosError('timeout of ' + timeout + 'ms exceeded', transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED, config, req));\n      });\n    }\n    if (config.cancelToken || config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = function (cancel) {\n        if (req.aborted) return;\n        req.abort();\n        reject(!cancel || cancel && cancel.type ? new CanceledError() : cancel);\n      };\n      config.cancelToken && config.cancelToken.subscribe(onCanceled);\n      if (config.signal) {\n        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n    // Send the request\n    if (utils.isStream(data)) {\n      data.on('error', function handleStreamError(err) {\n        reject(AxiosError.from(err, config, null, req));\n      }).pipe(req);\n    } else {\n      req.end(data);\n    }\n  });\n};","map":{"version":3,"names":["utils","require","settle","buildFullPath","buildURL","http","https","httpFollow","httpsFollow","url","zlib","VERSION","version","transitionalDefaults","AxiosError","CanceledError","isHttps","supportedProtocols","setProxy","options","proxy","location","hostname","host","port","path","auth","base64","Buffer","from","username","password","toString","headers","beforeRedirect","redirection","href","module","exports","httpAdapter","config","Promise","dispatchHttpRequest","resolvePromise","rejectPromise","onCanceled","done","cancelToken","unsubscribe","signal","removeEventListener","resolve","value","rejected","reject","data","headerNames","Object","keys","forEach","storeLowerName","name","toLowerCase","isFormData","isFunction","getHeaders","assign","isStream","isBuffer","isArrayBuffer","Uint8Array","isString","ERR_BAD_REQUEST","maxBodyLength","length","undefined","fullPath","baseURL","parsed","parse","protocol","indexOf","urlAuth","split","urlUsername","urlPassword","authorization","isHttpsRequest","test","agent","httpsAgent","httpAgent","params","paramsSerializer","replace","err","customErr","Error","message","exists","method","toUpperCase","agents","socketPath","proxyEnv","slice","proxyUrl","process","env","parsedProxyUrl","noProxyEnv","no_proxy","NO_PROXY","shouldProxy","noProxy","map","trim","s","some","proxyMatch","proxyElement","substr","proxyUrlAuth","transport","isHttpsProxy","maxRedirects","insecureHTTPParser","req","request","handleResponse","res","aborted","stream","lastRequest","statusCode","decompress","pipe","createUnzip","response","status","statusText","statusMessage","responseType","responseBuffer","totalResponseBytes","on","handleStreamData","chunk","push","maxContentLength","destroy","ERR_BAD_RESPONSE","handlerStreamAborted","handleStreamError","handleStreamEnd","responseData","concat","responseEncoding","stripBOM","handleRequestError","handleRequestSocket","socket","setKeepAlive","timeout","parseInt","isNaN","ERR_BAD_OPTION_VALUE","setTimeout","handleRequestTimeout","abort","transitional","clarifyTimeoutError","ETIMEDOUT","ECONNABORTED","cancel","type","subscribe","addEventListener","end"],"sources":["D:/Users/Mouse/Desktop/code/web/react/ms_draw_simulator/ms-simulator-web/node_modules/axios/lib/adapters/http.js"],"sourcesContent":["'use strict';\n\nvar utils = require('./../utils');\nvar settle = require('./../core/settle');\nvar buildFullPath = require('../core/buildFullPath');\nvar buildURL = require('./../helpers/buildURL');\nvar http = require('http');\nvar https = require('https');\nvar httpFollow = require('follow-redirects').http;\nvar httpsFollow = require('follow-redirects').https;\nvar url = require('url');\nvar zlib = require('zlib');\nvar VERSION = require('./../env/data').version;\nvar transitionalDefaults = require('../defaults/transitional');\nvar AxiosError = require('../core/AxiosError');\nvar CanceledError = require('../cancel/CanceledError');\n\nvar isHttps = /https:?/;\n\nvar supportedProtocols = [ 'http:', 'https:', 'file:' ];\n\n/**\n *\n * @param {http.ClientRequestArgs} options\n * @param {AxiosProxyConfig} proxy\n * @param {string} location\n */\nfunction setProxy(options, proxy, location) {\n  options.hostname = proxy.host;\n  options.host = proxy.host;\n  options.port = proxy.port;\n  options.path = location;\n\n  // Basic proxy authorization\n  if (proxy.auth) {\n    var base64 = Buffer.from(proxy.auth.username + ':' + proxy.auth.password, 'utf8').toString('base64');\n    options.headers['Proxy-Authorization'] = 'Basic ' + base64;\n  }\n\n  // If a proxy is used, any redirects must also pass through the proxy\n  options.beforeRedirect = function beforeRedirect(redirection) {\n    redirection.headers.host = redirection.host;\n    setProxy(redirection, proxy, redirection.href);\n  };\n}\n\n/*eslint consistent-return:0*/\nmodule.exports = function httpAdapter(config) {\n  return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {\n    var onCanceled;\n    function done() {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(onCanceled);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', onCanceled);\n      }\n    }\n    var resolve = function resolve(value) {\n      done();\n      resolvePromise(value);\n    };\n    var rejected = false;\n    var reject = function reject(value) {\n      done();\n      rejected = true;\n      rejectPromise(value);\n    };\n    var data = config.data;\n    var headers = config.headers;\n    var headerNames = {};\n\n    Object.keys(headers).forEach(function storeLowerName(name) {\n      headerNames[name.toLowerCase()] = name;\n    });\n\n    // Set User-Agent (required by some servers)\n    // See https://github.com/axios/axios/issues/69\n    if ('user-agent' in headerNames) {\n      // User-Agent is specified; handle case where no UA header is desired\n      if (!headers[headerNames['user-agent']]) {\n        delete headers[headerNames['user-agent']];\n      }\n      // Otherwise, use specified value\n    } else {\n      // Only set header if it hasn't been set in config\n      headers['User-Agent'] = 'axios/' + VERSION;\n    }\n\n    // support for https://www.npmjs.com/package/form-data api\n    if (utils.isFormData(data) && utils.isFunction(data.getHeaders)) {\n      Object.assign(headers, data.getHeaders());\n    } else if (data && !utils.isStream(data)) {\n      if (Buffer.isBuffer(data)) {\n        // Nothing to do...\n      } else if (utils.isArrayBuffer(data)) {\n        data = Buffer.from(new Uint8Array(data));\n      } else if (utils.isString(data)) {\n        data = Buffer.from(data, 'utf-8');\n      } else {\n        return reject(new AxiosError(\n          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',\n          AxiosError.ERR_BAD_REQUEST,\n          config\n        ));\n      }\n\n      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {\n        return reject(new AxiosError(\n          'Request body larger than maxBodyLength limit',\n          AxiosError.ERR_BAD_REQUEST,\n          config\n        ));\n      }\n\n      // Add Content-Length header if data exists\n      if (!headerNames['content-length']) {\n        headers['Content-Length'] = data.length;\n      }\n    }\n\n    // HTTP basic authentication\n    var auth = undefined;\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      auth = username + ':' + password;\n    }\n\n    // Parse url\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    var parsed = url.parse(fullPath);\n    var protocol = parsed.protocol || supportedProtocols[0];\n\n    if (supportedProtocols.indexOf(protocol) === -1) {\n      return reject(new AxiosError(\n        'Unsupported protocol ' + protocol,\n        AxiosError.ERR_BAD_REQUEST,\n        config\n      ));\n    }\n\n    if (!auth && parsed.auth) {\n      var urlAuth = parsed.auth.split(':');\n      var urlUsername = urlAuth[0] || '';\n      var urlPassword = urlAuth[1] || '';\n      auth = urlUsername + ':' + urlPassword;\n    }\n\n    if (auth && headerNames.authorization) {\n      delete headers[headerNames.authorization];\n    }\n\n    var isHttpsRequest = isHttps.test(protocol);\n    var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;\n\n    try {\n      buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\\?/, '');\n    } catch (err) {\n      var customErr = new Error(err.message);\n      customErr.config = config;\n      customErr.url = config.url;\n      customErr.exists = true;\n      reject(customErr);\n    }\n\n    var options = {\n      path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\\?/, ''),\n      method: config.method.toUpperCase(),\n      headers: headers,\n      agent: agent,\n      agents: { http: config.httpAgent, https: config.httpsAgent },\n      auth: auth\n    };\n\n    if (config.socketPath) {\n      options.socketPath = config.socketPath;\n    } else {\n      options.hostname = parsed.hostname;\n      options.port = parsed.port;\n    }\n\n    var proxy = config.proxy;\n    if (!proxy && proxy !== false) {\n      var proxyEnv = protocol.slice(0, -1) + '_proxy';\n      var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];\n      if (proxyUrl) {\n        var parsedProxyUrl = url.parse(proxyUrl);\n        var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;\n        var shouldProxy = true;\n\n        if (noProxyEnv) {\n          var noProxy = noProxyEnv.split(',').map(function trim(s) {\n            return s.trim();\n          });\n\n          shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {\n            if (!proxyElement) {\n              return false;\n            }\n            if (proxyElement === '*') {\n              return true;\n            }\n            if (proxyElement[0] === '.' &&\n                parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {\n              return true;\n            }\n\n            return parsed.hostname === proxyElement;\n          });\n        }\n\n        if (shouldProxy) {\n          proxy = {\n            host: parsedProxyUrl.hostname,\n            port: parsedProxyUrl.port,\n            protocol: parsedProxyUrl.protocol\n          };\n\n          if (parsedProxyUrl.auth) {\n            var proxyUrlAuth = parsedProxyUrl.auth.split(':');\n            proxy.auth = {\n              username: proxyUrlAuth[0],\n              password: proxyUrlAuth[1]\n            };\n          }\n        }\n      }\n    }\n\n    if (proxy) {\n      options.headers.host = parsed.hostname + (parsed.port ? ':' + parsed.port : '');\n      setProxy(options, proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);\n    }\n\n    var transport;\n    var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);\n    if (config.transport) {\n      transport = config.transport;\n    } else if (config.maxRedirects === 0) {\n      transport = isHttpsProxy ? https : http;\n    } else {\n      if (config.maxRedirects) {\n        options.maxRedirects = config.maxRedirects;\n      }\n      if (config.beforeRedirect) {\n        options.beforeRedirect = config.beforeRedirect;\n      }\n      transport = isHttpsProxy ? httpsFollow : httpFollow;\n    }\n\n    if (config.maxBodyLength > -1) {\n      options.maxBodyLength = config.maxBodyLength;\n    }\n\n    if (config.insecureHTTPParser) {\n      options.insecureHTTPParser = config.insecureHTTPParser;\n    }\n\n    // Create the request\n    var req = transport.request(options, function handleResponse(res) {\n      if (req.aborted) return;\n\n      // uncompress the response body transparently if required\n      var stream = res;\n\n      // return the last request in case of redirects\n      var lastRequest = res.req || req;\n\n\n      // if no content, is HEAD request or decompress disabled we should not decompress\n      if (res.statusCode !== 204 && lastRequest.method !== 'HEAD' && config.decompress !== false) {\n        switch (res.headers['content-encoding']) {\n        /*eslint default-case:0*/\n        case 'gzip':\n        case 'compress':\n        case 'deflate':\n        // add the unzipper to the body stream processing pipeline\n          stream = stream.pipe(zlib.createUnzip());\n\n          // remove the content-encoding in order to not confuse downstream operations\n          delete res.headers['content-encoding'];\n          break;\n        }\n      }\n\n      var response = {\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: res.headers,\n        config: config,\n        request: lastRequest\n      };\n\n      if (config.responseType === 'stream') {\n        response.data = stream;\n        settle(resolve, reject, response);\n      } else {\n        var responseBuffer = [];\n        var totalResponseBytes = 0;\n        stream.on('data', function handleStreamData(chunk) {\n          responseBuffer.push(chunk);\n          totalResponseBytes += chunk.length;\n\n          // make sure the content length is not over the maxContentLength if specified\n          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {\n            // stream.destoy() emit aborted event before calling reject() on Node.js v16\n            rejected = true;\n            stream.destroy();\n            reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded',\n              AxiosError.ERR_BAD_RESPONSE, config, lastRequest));\n          }\n        });\n\n        stream.on('aborted', function handlerStreamAborted() {\n          if (rejected) {\n            return;\n          }\n          stream.destroy();\n          reject(new AxiosError(\n            'maxContentLength size of ' + config.maxContentLength + ' exceeded',\n            AxiosError.ERR_BAD_RESPONSE,\n            config,\n            lastRequest\n          ));\n        });\n\n        stream.on('error', function handleStreamError(err) {\n          if (req.aborted) return;\n          reject(AxiosError.from(err, null, config, lastRequest));\n        });\n\n        stream.on('end', function handleStreamEnd() {\n          try {\n            var responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);\n            if (config.responseType !== 'arraybuffer') {\n              responseData = responseData.toString(config.responseEncoding);\n              if (!config.responseEncoding || config.responseEncoding === 'utf8') {\n                responseData = utils.stripBOM(responseData);\n              }\n            }\n            response.data = responseData;\n          } catch (err) {\n            reject(AxiosError.from(err, null, config, response.request, response));\n          }\n          settle(resolve, reject, response);\n        });\n      }\n    });\n\n    // Handle errors\n    req.on('error', function handleRequestError(err) {\n      // @todo remove\n      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;\n      reject(AxiosError.from(err, null, config, req));\n    });\n\n    // set tcp keep alive to prevent drop connection by peer\n    req.on('socket', function handleRequestSocket(socket) {\n      // default interval of sending ack packet is 1 minute\n      socket.setKeepAlive(true, 1000 * 60);\n    });\n\n    // Handle request timeout\n    if (config.timeout) {\n      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.\n      var timeout = parseInt(config.timeout, 10);\n\n      if (isNaN(timeout)) {\n        reject(new AxiosError(\n          'error trying to parse `config.timeout` to int',\n          AxiosError.ERR_BAD_OPTION_VALUE,\n          config,\n          req\n        ));\n\n        return;\n      }\n\n      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.\n      // And timer callback will be fired, and abort() will be invoked before connection, then get \"socket hang up\" and code ECONNRESET.\n      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.\n      // And then these socket which be hang up will devoring CPU little by little.\n      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.\n      req.setTimeout(timeout, function handleRequestTimeout() {\n        req.abort();\n        var transitional = config.transitional || transitionalDefaults;\n        reject(new AxiosError(\n          'timeout of ' + timeout + 'ms exceeded',\n          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,\n          config,\n          req\n        ));\n      });\n    }\n\n    if (config.cancelToken || config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = function(cancel) {\n        if (req.aborted) return;\n\n        req.abort();\n        reject(!cancel || (cancel && cancel.type) ? new CanceledError() : cancel);\n      };\n\n      config.cancelToken && config.cancelToken.subscribe(onCanceled);\n      if (config.signal) {\n        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n\n    // Send the request\n    if (utils.isStream(data)) {\n      data.on('error', function handleStreamError(err) {\n        reject(AxiosError.from(err, config, null, req));\n      }).pipe(req);\n    } else {\n      req.end(data);\n    }\n  });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}